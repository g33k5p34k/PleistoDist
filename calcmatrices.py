import numpy as np
import pandas as pd
import os

#set working directory to current file directory
os.chdir(os.path.dirname(os.path.abspath(__file__)))
#set current directory as path variable
path = os.getcwd()

#outpath = "examples/output/"

#create blank array for containing distance matrix file names
leastdistfiles = []
eucdistfiles = []
leastcostfiles = []

def calcmatrices_island(outpath,intervalfile):
    #extract list of intervals
    intervals = intervalfile['Interval'].tolist()
    #extract list of time durations for each interval, which will be used as the weights for averaging
    weights = np.array(intervalfile['TimeInterval'].tolist())

    #create list of distance matrices for least distance and inter-centroid euclidean distance
    for i in intervals:
        leastdistfiles.append("island_leastdist_interval{}.csv".format(i))
        eucdistfiles.append("islandcentroid_euclidean_interval{}.csv".format(i))

    #read distance matrices generated by islandmode.py from output folder, create dataframe of distance matrix dataframes
    leastdist_dfs = [pd.read_csv(outpath+f, header=0, index_col=0) for f in leastdistfiles]
    eucdist_dfs = [pd.read_csv(outpath+g, header=0, index_col=0) for g in eucdistfiles]

    #concatenate and group dataframes by FID value
    leastdist_df = pd.concat(leastdist_dfs).groupby(level=0)
    eucdist_df = pd.concat(eucdist_dfs).groupby(level=0)

    #open file for writing final weighted average distance matrix
    f = open(outpath+"island_leastdist_averaged.csv","w")
    g = open(outpath+"islandcentroid_euclidean_averaged.csv","w")

    #create array of number of points
    points = range(0,len(leastdist_df))
    #prepare header string and write to file
    header = "FID,"+",".join(map(str,points))+"\n"
    f.write(header)
    g.write(header)

    #reshape time interval array to facilitate calculation of weighted average distance
    #weights_reshaped = weights.reshape(len(leastdist_dfs),1)

    #start iterating through interval matrices and calculate weighted average across all intervals
    for x in points: #iterate through source FID values
        leastdistrow= [str(x)] #write source FID value to first column
        eucdistrow = [str(x)] #write source FID value to first column
        for y in points: #iterate through sink FID values
            leastdistarray = np.array(leastdist_df.get_group(x)[[str(y)]]) #convert list of values across all intervals for that particular source/sink combination into an array
            leastdistmasked = np.ma.masked_array(leastdistarray,np.isnan(leastdistarray)) #mask out NA values from the array
            leastdistavg = np.ma.average(leastdistmasked, axis = 0, weights=weights) #calculate weighted average based on array values and time interval weights
            leastdistrow.append(str(float(leastdistavg))) #add weighted average value to container variable
            eucdistarray = np.array(eucdist_df.get_group(x)[[str(y)]]) #convert list of values across all intervals for that particular source/sink combination into an array
            eucdistmasked = np.ma.masked_array(eucdistarray,np.isnan(eucdistarray)) #mask out NA values from the array
            eucdistavg = np.ma.average(eucdistmasked,axis=0,weights=weights) #calculate weighted average based on array values and time interval weights
            eucdistrow.append(str(float(eucdistavg))) #add weighted average value to container variable
        leastdist = ','.join(leastdistrow) #convert container variable into string and write to file
        eucdist = ','.join(eucdistrow) #convert container variable into string and write to file
        f.write(leastdist+"\n")
        g.write(eucdist+"\n")
    f.close() #close files
    g.close()
    
def calcmatrices_indiv(outpath,intervalfile):
    #extract list of intervals
    intervals = intervalfile['Interval'].tolist()
    #extract list of time durations for each interval, which will be used as the weights for averaging
    weights = np.array(intervalfile['TimeInterval'].tolist())

    #create list of distance matrices for least distance and inter-centroid euclidean distance
    for i in intervals:
        leastcostfiles.append("individual_leastcost_interval{}.csv".format(i))

    #read distance matrices generated by individualmode.py from output folder, create dataframe of distance matrix dataframes
    leastcost_dfs = [pd.read_csv(outpath+f, header=0, index_col=0) for f in leastcostfiles]

    #concatenate and group dataframes by FID value
    leastcost_df = pd.concat(leastcost_dfs).groupby(level=0)

    #open file for writing final weighted average distance matrix
    h = open(outpath+"individual_leastcost_averaged.csv","w")

    #create array of number of points
    points = range(0,len(leastcost_df))
    #prepare header string and write to file
    header = "FID,"+",".join(map(str,points))+"\n"
    h.write(header)

    #reshape time interval array to facilitate calculation of weighted average distance
    #weights_reshaped = weights.reshape(len(leastdist_dfs),1)

    #start iterating through interval matrices and calculate weighted average across all intervals
    for x in points: #iterate through source FID values
        leastcostrow= [str(x)] #write source FID value to first column
        for y in points: #iterate through sink FID values
            leastcostarray = np.array(leastcost_df.get_group(x)[[str(y)]]) #convert list of values across all intervals for that particular source/sink combination into an array
            leastcostmasked = np.ma.masked_array(leastcostarray,np.isnan(leastcostarray)) #mask out NA values from the array
            leastcostavg = np.ma.average(leastcostmasked, axis = 0, weights=weights) #calculate weighted average based on array values and time interval weights
            leastcostrow.append(str(float(leastcostavg))) #add weighted average value to container variable
        leastcost = ','.join(leastcostrow) #convert container variable into string and write to file
        h.write(leastcost+"\n")
    h.close() #close files